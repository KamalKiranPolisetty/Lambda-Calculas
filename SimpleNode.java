/* Generated By:JJTree: Do not edit this line. SimpleNode.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */

import java.util.HashSet;
import java.util.Set;

public
class SimpleNode implements Node {

  protected Node parent;
  protected Node[] children;
  protected int id;
  protected Object value;
  protected Prog2 parser;

  public SimpleNode(int i) {
    id = i;
  }

  public SimpleNode(Prog2 p, int i) {
    this(i);
    parser = p;
  }

  public void jjtOpen() {
  }

  public void jjtClose() {
  }

  public void jjtSetParent(Node n) { parent = n; }
  public Node jjtGetParent() { return parent; }

  public void jjtAddChild(Node n, int i) {
    if (children == null) {
      children = new Node[i + 1];
    } else if (i >= children.length) {
      Node c[] = new Node[i + 1];
      System.arraycopy(children, 0, c, 0, children.length);
      children = c;
    }
    children[i] = n;
  }

  public Node jjtGetChild(int i) {
    return children[i];
  }

  public int jjtGetNumChildren() {
    return (children == null) ? 0 : children.length;
  }

  public void jjtSetValue(Object value) { this.value = value; }
  public Object jjtGetValue() { return value; }

  /* You can override these two methods in subclasses of SimpleNode to
     customize the way the node appears when the tree is dumped.  If
     your output uses more than one line you should override
     toString(String), otherwise overriding toString() is probably all
     you need to do. */

  public String toString() {
    return Prog2TreeConstants.jjtNodeName[id];
  }
  public String toString(String prefix) { return prefix + toString(); }

  /* Override this method if you want to customize how the node dumps
     out its children. */
/*----------------------------------------------------------------------------*/
//function astToString
public String astToString() {
  StringBuilder sb = new StringBuilder();
  switch (Prog2TreeConstants.jjtNodeName[id]) {
    case "Start":
      sb.append(jjtGetChild(0).astToString());
      break;
    case "lamb":
      sb.append("(L ");
      sb.append(jjtGetChild(0).astToString());
      sb.append(" . ");
      sb.append(jjtGetChild(1).astToString());
      sb.append(")");
      break;
    case "MyID":
    case "Integer":
      sb.append(toString());
      break;
    case "add":
      sb.append("+ ");
      break;
    case "sub":
      sb.append("- ");
      break;
    case "mul":
      sb.append("* ");
      break;
    case "div":
      sb.append("/ ");
      break;
    case "mod":
      sb.append("% ");
      break;
    case "appl":
      sb.append("(");
      sb.append(jjtGetChild(0).astToString());
      sb.append(" ");
      sb.append(jjtGetChild(1).astToString());
      sb.append(")");
      break;
    default:
      break;
  }
  return sb.toString();
}
/*----------------------------------------------------------------------------*/
//function FV()
public Set<String> FV() {
  Set<String> fv = new HashSet<>();
  switch (Prog2TreeConstants.jjtNodeName[id]) {
    case "Start":
      if (jjtGetNumChildren() > 0) {
        fv.addAll(jjtGetChild(0).FV());
      }
      break;
    case "lamb":
      Set<String> bodyFV = jjtGetChild(1).FV();
      String paramName = jjtGetChild(0).toString();
      bodyFV.remove(paramName);
      fv.addAll(bodyFV);
      break;
    case "MyID":
      fv.add(toString());
      break;
    case "appl":
      for (int i = 0; i < jjtGetNumChildren(); i++) {
        fv.addAll(jjtGetChild(i).FV());
      }
      break;
  }
  return fv;
}

// Function dumpFV()
public void dumpFV(String prefix) {
  Set<String> fv = FV();
  if (!"Start".equals(Prog2TreeConstants.jjtNodeName[id])) {
    System.out.println(toString(prefix) + " " + (fv.isEmpty() ? "[]" : fv));
  }
  if (children != null) {
    for (int i = 0; i < children.length; ++i) {
      SimpleNode n = (SimpleNode) children[i];
      if (n != null) {
        n.dumpFV(prefix + " ");
      }
    }
  }
}

/*----------------------------------------------------------------------------*/

public static int count = 0;
public SimpleNode substitute(String var, SimpleNode expr) {
  if ("Start".equals(Prog2.jjtNodeName[id])) {
    if (jjtGetNumChildren() > 0) {
      for (int i = 0; i < jjtGetNumChildren(); i++) {
        SimpleNode child = (SimpleNode) jjtGetChild(i);
        child.substitute(var, expr);
      }
    }
  }
  switch (Prog2TreeConstants.jjtNodeName[id]) {
    case "MyID":
      if (this.toString().equals(var)) {
        return expr.cloneTree();
      }
      break;
    case "appl":
      this.jjtAddChild(((SimpleNode) children[0]).substitute(var, expr.cloneTree()), 0);
      this.jjtAddChild(((SimpleNode) children[1]).substitute(var, expr.cloneTree()), 1);
      return this.cloneTree();
    case "lamb":
      String paramName = children[0].toString();
      if (paramName.equals(var)) {
        return this.cloneTree();
      } else if (!expr.FV().contains(paramName)) {
        ((SimpleNode) children[1]).substitute(var, expr.cloneTree());
        return this.cloneTree();
      } else {
        String x = "" + String.valueOf(count) + children[0].toString();
        count++;
        String oldParamName = children[0].toString();
        ((ASTMyID) children[0]).setName(x);
        ((SimpleNode) children[1]).substitute(oldParamName, ((SimpleNode) children[0]).cloneTree());
        ((SimpleNode) children[1]).substitute(var, expr.cloneTree());
        return this.cloneTree();
      }
    default:
      return this.cloneTree();
  }
  return this;
}


public SimpleNode cloneTree() {
  SimpleNode clone = this.clone(this.id);
  for (int i = 0; i < jjtGetNumChildren(); i++) {
    SimpleNode child = (SimpleNode) jjtGetChild(i);

    clone.jjtAddChild(child.cloneTree(), i);
  }

  return clone;
}

public SimpleNode clone(int id) {

  return new SimpleNode(id);
}
/*-------------------------------------------------------------------------*/

public boolean betaReduxNodeCheck() {
        if (this instanceof ASTappl && this.jjtGetChild(0) instanceof ASTlamb) {
            return true;
        } else {
            return false;
        }
    }

    public boolean betaReduxTreeCheck() {
        if (children != null) {
            if (this.betaReduxNodeCheck()) {
                return true;
            } else {
                return ((SimpleNode) this.jjtGetChild(0)).betaReduxTreeCheck()
                        || ((SimpleNode) this.jjtGetChild(1)).betaReduxTreeCheck();
            }
        }
        return false;
    }

    public boolean deltaReduxNodeCheck() {
        if (children == null) {
            return false;
        } else if (this instanceof ASTappl) {
            if (this.jjtGetChild(0).jjtGetNumChildren() == 0) {
                return false;
            } else {
                boolean operator = (this.jjtGetChild(0).jjtGetChild(0)).toString().equals("add")
                        || (this.jjtGetChild(0).jjtGetChild(0)).toString().equals("sub")
                        || (this.jjtGetChild(0).jjtGetChild(0)).toString().equals("mul")
                        || (this.jjtGetChild(0).jjtGetChild(0)).toString().equals("div");

                return this instanceof ASTappl && this.jjtGetChild(1) instanceof ASTInteger
                        && operator
                        && this.jjtGetChild(0) instanceof ASTappl
                        && ((SimpleNode) this.jjtGetChild(0)).jjtGetChild(1) instanceof ASTInteger;
            }
        } else {
            return false;
        }
    }

    public boolean deltaReduxTreeCheck() {
        if (children == null) {
            return false;
        } else if (this instanceof ASTappl) {
            if (this.deltaReduxNodeCheck()) {
                return true;
            } else {
                return (((SimpleNode) this.jjtGetChild(0)).deltaReduxTreeCheck()
                        || ((SimpleNode) this.jjtGetChild(1)).deltaReduxTreeCheck());
            }
        } else {
            return ((SimpleNode) this.jjtGetChild(1)).betaReduxTreeCheck();
        }
    }

    public SimpleNode applyBetaReduction() {
        SimpleNode currentNode = this;
        SimpleNode rightChildAppl = (SimpleNode) this.jjtGetChild(1);// right subtree node
        SimpleNode lefttChildLamb = (SimpleNode) this.jjtGetChild(0).jjtGetChild(0);// left subtree Node
        SimpleNode rightChildLamb = (SimpleNode) this.jjtGetChild(0).jjtGetChild(1);// right node of left subtree
        rightChildLamb = rightChildLamb.substitute(lefttChildLamb.toString(), rightChildAppl.cloneTree());// substituting rightsubtree in occurences of lamb parameter
        currentNode = rightChildLamb.cloneTree();// currentNode has modified expression node
        return currentNode.cloneTree();
    }

    public SimpleNode applyDeltaReduction() {
        SimpleNode rightChild = (SimpleNode) this.jjtGetChild(1); // right node
        SimpleNode leftRightGrandchild = (SimpleNode) ((SimpleNode) this.jjtGetChild(0)).jjtGetChild(1);// left subtree right node                                                                    
        // check the operator
        if ((this.jjtGetChild(0).jjtGetChild(0)).toString().equals("add")) {
            int left = Integer.parseInt(leftRightGrandchild.toString());
            int right = Integer.parseInt(rightChild.toString());
            int sum = left + right;
            ASTInteger tempNode = new ASTInteger(rightChild.id);
            tempNode.setValue(String.valueOf(sum));
            return tempNode;
        } else if ((this.jjtGetChild(0).jjtGetChild(0)).toString().equals("sub")) {

            int left = Integer.parseInt(leftRightGrandchild.toString());
            int right = Integer.parseInt(rightChild.toString());
            int sub = left - right;
            ASTInteger tempNode = new ASTInteger(rightChild.id);
            tempNode.setValue(String.valueOf(sub));
            return tempNode;
        } else if ((this.jjtGetChild(0).jjtGetChild(0)).toString().equals("div")) {

            int left = Integer.parseInt(leftRightGrandchild.toString());
            int right = Integer.parseInt(rightChild.toString());
            int div = left / right;
            ASTInteger tempNode = new ASTInteger(rightChild.id);
            tempNode.setValue(String.valueOf(div));
            return tempNode;
        } else {
            int left = Integer.parseInt(leftRightGrandchild.toString());
            int right = Integer.parseInt(rightChild.toString());
            int mul = left * right;
            ASTInteger tempNode = new ASTInteger(rightChild.id);
            tempNode.setValue(String.valueOf(mul));
            return tempNode;
        }
    }

    public SimpleNode removeDeltaRedux() {
        SimpleNode currentNode = this.cloneTree();
        if (currentNode.deltaReduxNodeCheck()) { // check current delta redux
            currentNode = currentNode.applyDeltaReduction();
            return currentNode.cloneTree();
        } else if (((SimpleNode) this.jjtGetChild(0)).deltaReduxTreeCheck()) { // check for left subtree deltaredux if not righttree deltaredux                                                                         
            SimpleNode leftChild = ((SimpleNode) currentNode.jjtGetChild(0)).removeDeltaRedux();
            currentNode.jjtAddChild(leftChild.cloneTree(), 0);
            return currentNode.cloneTree();
        } else {
            SimpleNode rightChild = ((SimpleNode) currentNode.jjtGetChild(1)).removeDeltaRedux();
            currentNode.jjtAddChild(rightChild.cloneTree(), 1);
            return currentNode.cloneTree();
        }
    }

    public SimpleNode removeBetaRedux() {
        SimpleNode currentNode = this.cloneTree();
        if (currentNode.betaReduxNodeCheck()) { // check current beta redux
            currentNode = currentNode.applyBetaReduction();
            return currentNode.cloneTree();
        } else if (((SimpleNode) this.jjtGetChild(0)).betaReduxTreeCheck()) { // check for left subtree betaredux if not righttree betaredux                                                                     
            SimpleNode leftChild = ((SimpleNode) currentNode.jjtGetChild(0)).removeBetaRedux();
            currentNode.jjtAddChild(leftChild.cloneTree(), 0);
            return currentNode.cloneTree();
        } else {
            SimpleNode rightChild = ((SimpleNode) currentNode.jjtGetChild(1)).removeBetaRedux();
            currentNode.jjtAddChild(rightChild.cloneTree(), 1);
            return currentNode.cloneTree();
        }
    }

    public SimpleNode normalOrderEvaluate() {
        SimpleNode currentNode = this.cloneTree();
        while (currentNode.betaReduxTreeCheck()) {
            currentNode = currentNode.removeBetaRedux();
        }
        while (currentNode.deltaReduxTreeCheck()) {
            currentNode = currentNode.removeDeltaRedux();
        }
        return currentNode;
    }


/*----------------------------------------------------------------------------*/
  public void dump(String prefix) {
       if (!"Start".equals(Prog2TreeConstants.jjtNodeName[id])) {
        System.out.println(toString(prefix)); 
    }
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
        SimpleNode n = (SimpleNode)children[i];
        if (n != null) {
          n.dump(prefix + " ");
        }
      }
    }
  }
  public int getId() {
    return id;
  }
}

/* JavaCC - OriginalChecksum=39d3cd8b4eb8ea35d58d21dc28f0c660 (do not edit this line) */